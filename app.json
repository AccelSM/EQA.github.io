[{"name": "app.py", "content": "from shiny import App, reactive, render, ui\nfrom shinywidgets import output_widget, render_widget\nimport plotly.graph_objects as go\nimport shinyswatch\nimport math\nimport numpy as np\n\n# --- UI (Interfaz de Usuario) ---\napp_ui = ui.page_fluid(\n      \n    ui.panel_title(\"Simulador de Curvas de Titulaci\u00f3n\"),\n    \n\n    ui.layout_sidebar( \n        ui.sidebar(\n            ui.h4(\"Configuraci\u00f3n General\"),\n            ui.input_radio_buttons(\n                \"tipo_titulacion\", \n                \"Titulante\",\n                choices={\n                    \"ab\": \"Base\",\n                    \"ba\": \"\u00c1cido\"\n                },\n                selected=\"ab\"\n            ),\n            ui.hr(),\n            ui.h4(\"Variables operatorias\"),\n            ui.input_numeric(\"v0\", \"Volumen Inicial (mL)\", value=50),\n            ui.input_numeric(\"ct\", \"Concentraci\u00f3n Titulante (mol/L)\", value=0.1),\n            ui.hr(),\n            ui.h4(\"Composici\u00f3n\"),\n            ui.input_numeric(\"num_componentes\", \"N\u00famero de Componentes\", value=1, min=1, max=5),\n            ui.p(\"\"),\n            ui.input_action_button(\"btn_calc\", \"Calcular y Graficar\", class_=\"btn-primary\"),\n            \n            ui.hr(),\n            ui.h5(\"Gr\u00e1ficos Adicionales\"),\n            ui.input_checkbox(\"show_deriv1\", \"Primera Derivada\", value=False),\n            ui.input_checkbox(\"show_deriv2\", \"Capacidad Amortiguadora\", value=False),\n            ui.input_checkbox(\"use_log\", \"Escala Logar\u00edtmica\", value=True),\n            ui.help_text(\" \")\n        ),\n        \n        ui.layout_columns(\n            ui.card(\n                ui.card_header(\"Componentes\"),\n                ui.output_ui(\"ui_componentes\")\n            ),\n            ui.card(\n                ui.card_header(\"Curva de Titulaci\u00f3n\"),\n                output_widget(\"curva_titulacion\", height=\"600px\"),\n                ui.help_text(\"Pasa el cursor para ver los valores exactos.\")\n            ),\n            col_widths=(5, 7) \n        )\n    ),\n    theme = shinyswatch.theme.cerulean\n\n)\n\n# --- Funci\u00f3n Auxiliar de C\u00e1lculo ---\ndef calcular_vag_para_ph(pH_val, V0, CT, componentes, tipo_titulacion=\"ab\"):\n    Kw = 1e-14\n    H = 10**(-pH_val)\n    OH = Kw / H\n    \n    # 1. Definir signos y t\u00e9rminos de Agua seg\u00fan el tipo de titulaci\u00f3n\n    if tipo_titulacion == \"ab\":\n        term_agua = OH - H\n        numerador_agua = V0 * term_agua\n        denominator_total = CT + H - OH\n    else:\n        term_agua = H - OH\n        numerador_agua = V0 * term_agua\n        denominator_total = CT - H + OH\n    \n    numerador_sumas = 0\n    \n    # 2. Sumatoria de componentes\n    for comp in componentes:\n        CM = comp['CM']\n        VM = comp['VM']\n        n = comp['n']\n        z = comp['z']\n        n_analito = comp['n_analito']\n        betas = comp['betas']\n        es_fuerte = comp.get('strong', False) \n\n        fraction = 0\n\n        if es_fuerte:\n            if tipo_titulacion == \"ba\":\n                fraction = 0\n            else:\n                fraction = 1.0\n        else:\n            sum_num_inner = 0\n            sum_den_inner = 0\n            \n            for i in range(len(betas)): \n                term_conc = betas[i] * (H**i)\n                sum_num_inner += (n - i + z) * term_conc\n                sum_den_inner += term_conc\n            \n            fraction = sum_num_inner / sum_den_inner if sum_den_inner != 0 else 0\n        \n        term_j = CM * VM * (fraction - n + n_analito)\n        numerador_sumas += term_j\n\n    # 3. Ensamblaje final\n    if tipo_titulacion == \"ba\":\n        numerator_total = numerador_agua - numerador_sumas\n    else:\n        numerator_total = numerador_agua + numerador_sumas\n\n    if denominator_total == 0:\n        return float('nan') \n\n    return numerator_total / denominator_total\n\n# --- Server (L\u00f3gica) ---\ndef server(input, output, session):\n\n    def get_val(input_id, default_val):\n        with reactive.isolate(): \n            try:\n                val = input[input_id]()\n                return val if val is not None else default_val\n            except:\n                return default_val\n\n    @render.ui\n    def ui_componentes():\n        m = input.num_componentes()\n        cards = []\n        \n        for i in range(m):\n            v_cm = get_val(f\"cm_{i}\", 0.01)\n            v_vm = get_val(f\"vm_{i}\", 10)\n            v_n = get_val(f\"n_protones_{i}\", 1)\n            v_z = get_val(f\"z_pol_{i}\", 0)\n            v_na = get_val(f\"n_analito_{i}\", 0)\n            v_strong = get_val(f\"strong_{i}\", False)\n\n            cards.append(\n                ui.card(\n                    ui.card_header(f\"Componente #{i+1}\"),\n                    ui.layout_columns(\n                        ui.input_numeric(f\"cm_{i}\", \"Concentraci\u00f3n (mol/L)\", value=v_cm),\n                        ui.input_numeric(f\"vm_{i}\", \"Volumen de al\u00edcuota (mL)\", value=v_vm),\n                    ),\n                    ui.layout_columns(\n                         ui.input_numeric(f\"n_protones_{i}\", \"Protones del polidonador\", value=v_n, min=1, max=10),\n                         ui.input_numeric(f\"z_pol_{i}\", \"Carga del polidonador\", value=v_z),\n                         ui.input_numeric(f\"n_analito_{i}\", \"Protones del analito\", value=v_na),\n                    ),\n                    ui.input_checkbox(f\"strong_{i}\", \"Especie nivelada\", value=v_strong),\n                    ui.hr(),\n                    ui.h6(\"Constantes de formaci\u00f3n (Log \u03b2)\"),\n                    ui.output_ui(f\"ui_betas_container_{i}\")\n                )\n            )\n            cards.append(ui.br())\n            \n        return ui.TagList(cards)\n\n    def render_beta_inputs(index):\n        try:\n            n = input[f\"n_protones_{index}\"]()\n            if n is None: return ui.div()\n        except:\n            return ui.div() \n        \n        inputs = []\n        for k in range(n):\n            input_id = f\"log_beta_{index}_{k}\"\n            label = f\"Log \u03b2{k+1}\"\n            default_logic = (k + 1) * 4\n            v_beta = get_val(input_id, default_logic)\n            \n            box = ui.input_numeric(input_id, label, value=v_beta)\n            inputs.append(box)\n        \n        return ui.layout_columns(*inputs, col_widths=4)\n\n    @render.ui\n    def ui_betas_container_0(): return render_beta_inputs(0)\n    @render.ui\n    def ui_betas_container_1(): return render_beta_inputs(1)\n    @render.ui\n    def ui_betas_container_2(): return render_beta_inputs(2)\n    @render.ui\n    def ui_betas_container_3(): return render_beta_inputs(3)\n    @render.ui\n    def ui_betas_container_4(): return render_beta_inputs(4)\n\n    def obtener_datos_componentes():\n        m = input.num_componentes()\n        lista_comps = []\n        for j in range(m):\n            n = input[f\"n_protones_{j}\"]()\n            betas_list = []\n            for k in range(n):\n                try:\n                    log_val = input[f\"log_beta_{j}_{k}\"]()\n                    val = log_val if log_val is not None else 0\n                    betas_list.append(10**val)\n                except:\n                    betas_list.append(1.0) \n\n            lista_comps.append({\n                'CM': input[f\"cm_{j}\"](),\n                'VM': input[f\"vm_{j}\"](),\n                'n': n,\n                'z': input[f\"z_pol_{j}\"](),\n                'n_analito': input[f\"n_analito_{j}\"](),\n                'betas': [1.0] + betas_list,\n                'strong': input[f\"strong_{j}\"]() \n            })\n        return lista_comps\n\n    # --- 4. C\u00e1lculo Reactivo (MODIFICADO) ---\n    @reactive.calc\n    @reactive.event(input.btn_calc)\n    def datos_curva():\n        V0 = input.v0()\n        CT = input.ct()\n        tipo = input.tipo_titulacion() \n        comps = obtener_datos_componentes()\n        \n        ph_values = np.linspace(0, 14, 2000)\n        vag_values = []\n        valid_ph = []\n\n        # MODIFICACI\u00d3N: L\u00edmite basado en equivalentes totales / concentraci\u00f3n titulante\n        try:\n            # Suma de (Volumen_i * Concentraci\u00f3n_i * Protones_i)\n            suma_equivalentes = sum(c['VM'] * c['CM'] * c['n'] for c in comps)\n            limit_vol = 1.2 * (suma_equivalentes / CT)\n        except ZeroDivisionError:\n            limit_vol = 1.2 * V0  # Fallback si CT es cero\n\n        for ph in ph_values:\n            try:\n                v = calcular_vag_para_ph(ph, V0, CT, comps, tipo_titulacion=tipo)\n                if 0 <= v <= limit_vol:\n                    vag_values.append(v)\n                    valid_ph.append(ph)\n            except:\n                pass\n        \n        return vag_values, valid_ph\n\n    # --- 5. Gr\u00e1fico Interactivo con Plotly ---\n    @render_widget\n    def curva_titulacion():\n        vag_values, valid_ph = datos_curva()\n\n        fig = go.Figure()\n\n        if not vag_values:\n            fig.add_annotation(\n                text=\"Sin datos v\u00e1lidos.\",\n                xref=\"paper\", yref=\"paper\", x=0.5, y=0.5, showarrow=False\n            )\n            return fig\n            \n        tipo = input.tipo_titulacion()\n        color_linea = 'blue' if tipo == 'ab' else 'green'\n\n        fig.add_trace(go.Scatter(\n            x=vag_values,\n            y=valid_ph,\n            mode='lines',\n            name=\"Curva de titulaci\u00f3n\",\n            line=dict(color=color_linea, width=3),\n            hovertemplate='<b>Vol:</b> %{x:.2f} mL<br><b>pH:</b> %{y:.2f}'\n        ))\n\n        if len(vag_values) > 5 and (input.show_deriv1() or input.show_deriv2()):\n            arr_v = np.array(vag_values)\n            arr_ph = np.array(valid_ph)\n            \n            idx = np.argsort(arr_v)\n            v_sorted = arr_v[idx]\n            ph_sorted = arr_ph[idx]\n            \n            d_ph = np.gradient(ph_sorted, v_sorted)\n            \n            if input.show_deriv1():\n                y_d1 = np.abs(d_ph)\n                fig.add_trace(go.Scatter(\n                    x=v_sorted,\n                    y=y_d1,\n                    mode='lines',\n                    name='1\u00aa Derivada',\n                    line=dict(color='orange', width=1, dash='dot'),\n                    yaxis='y2'\n                ))\n\n            if input.show_deriv2():\n                with np.errstate(divide='ignore', invalid='ignore'):\n                    d_v = 1.0 / d_ph\n                \n                CT = input.ct()\n                y_d2 = np.abs(d_v * CT)\n\n                fig.add_trace(go.Scatter(\n                    x=v_sorted,\n                    y=y_d2,\n                    mode='lines',\n                    name='\u03b2',\n                    line=dict(color='purple', width=1, dash='dash'),\n                    yaxis='y2',\n                    fill='tozeroy', \n                    fillcolor='rgba(128, 0, 128, 0.1)'\n                ))\n\n        fig.update_layout(\n            xaxis_title=\"Volumen Agregado (mL)\",\n            yaxis=dict(title=\"pH\", range=[0, 14]),\n            yaxis2=dict(\n                title=\"1\u00aa Derivada / \u03b2\",\n                overlaying=\"y\",\n                side=\"right\",\n                type=\"log\" if input.use_log() else \"linear\",\n                showgrid=False\n            ),\n            hovermode=\"x unified\",\n            template=\"simple_white\",\n            margin=dict(l=40, r=40, t=40, b=40)\n        )\n        \n        return fig\n\napp = App(app_ui, server)", "type": "text"}, {"name": "requirements.txt", "content": "shiny\nshinywidgets\nplotly\nshinyswatch\nnumpy", "type": "text"}]